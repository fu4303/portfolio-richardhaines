{"expireTime":9007200851906806000,"key":"gatsby-plugin-mdx-entire-payload-0d2b4fffaceb5647546c39e1a8b9a66e-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import AccentBox from \"../src/components/site/blog/accent-box.js\";","position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":67,"offset":68},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Cloudinary is a great resource for handling and managing your images, with dynamic query string manipulation of the images you can deliver optimized, pictures to fit any applications needs. I've dabbled with it before but never really needed it in a project before. That was until I found myself with a real use case, to allow users to upload and store their social profile and cover photos in my latest project ","position":{"start":{"line":4,"column":1,"offset":72},"end":{"line":4,"column":413,"offset":484},"indent":[]}},{"type":"link","title":null,"url":"https://www.devpack.dev/","children":[{"type":"text","value":"devpack","position":{"start":{"line":4,"column":414,"offset":485},"end":{"line":4,"column":421,"offset":492},"indent":[]}}],"position":{"start":{"line":4,"column":413,"offset":484},"end":{"line":4,"column":448,"offset":519},"indent":[]}},{"type":"text","value":".","position":{"start":{"line":4,"column":448,"offset":519},"end":{"line":4,"column":449,"offset":520},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":72},"end":{"line":4,"column":449,"offset":520},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"I'd been made aware of a new hooks library built to harness the power of Cloudinary in React apps by it's creator ","position":{"start":{"line":6,"column":1,"offset":524},"end":{"line":6,"column":115,"offset":638},"indent":[]}},{"type":"link","title":null,"url":"https://twitter.com/domitriusclark","children":[{"type":"text","value":"Domitrius Clark","position":{"start":{"line":6,"column":116,"offset":639},"end":{"line":6,"column":131,"offset":654},"indent":[]}}],"position":{"start":{"line":6,"column":115,"offset":638},"end":{"line":6,"column":168,"offset":691},"indent":[]}},{"type":"text","value":", a dev rel at Cloudinary. Excited to try this new library out I combined it with an easy to use image dropzone package called ","position":{"start":{"line":6,"column":168,"offset":691},"end":{"line":6,"column":295,"offset":818},"indent":[]}},{"type":"link","title":null,"url":"https://react-dropzone.js.org/","children":[{"type":"text","value":"react-dropzone","position":{"start":{"line":6,"column":296,"offset":819},"end":{"line":6,"column":310,"offset":833},"indent":[]}}],"position":{"start":{"line":6,"column":295,"offset":818},"end":{"line":6,"column":343,"offset":866},"indent":[]}},{"type":"text","value":" and serverless functions. Having hit a few early snags, Dom was super helpful in getting me setup and on the correct path with how to use the lib! Now, shall we build something? LETS GOOOOOOOOOO! ðŸ˜œ","position":{"start":{"line":6,"column":343,"offset":866},"end":{"line":6,"column":542,"offset":1065},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":524},"end":{"line":6,"column":542,"offset":1065},"indent":[]}},{"type":"jsx","value":"<AccentBox>\n  This article assumes some prior knowledge of React, React hooks and Gatsby. It wont be covering version control or\n  Netlify site setup.\n</AccentBox>","position":{"start":{"line":8,"column":1,"offset":1069},"end":{"line":11,"column":13,"offset":1235},"indent":[1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Setup","position":{"start":{"line":13,"column":4,"offset":1242},"end":{"line":13,"column":9,"offset":1247},"indent":[]}}],"position":{"start":{"line":13,"column":1,"offset":1239},"end":{"line":13,"column":9,"offset":1247},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Let's do a clean install of Gatsby to get things up and running. You'll need a Netlify account also so that we can run the netlify-cli to locally check our serverless function is working correctly. Create a new folder which will house your project.","position":{"start":{"line":15,"column":1,"offset":1251},"end":{"line":15,"column":249,"offset":1499},"indent":[]}}],"position":{"start":{"line":15,"column":1,"offset":1251},"end":{"line":15,"column":249,"offset":1499},"indent":[]}},{"type":"code","lang":"bash","meta":null,"value":"yarn init -y\nyarn add react react-dom gatsby netlify-cli use-cloudinary cloudinary react-dropzone dotenv","position":{"start":{"line":17,"column":1,"offset":1503},"end":{"line":20,"column":4,"offset":1622},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Add some default folders and files.","position":{"start":{"line":22,"column":1,"offset":1626},"end":{"line":22,"column":36,"offset":1661},"indent":[]}}],"position":{"start":{"line":22,"column":1,"offset":1626},"end":{"line":22,"column":36,"offset":1661},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"mkdir src/pages\nmkdir src/components\nmkdir functions","position":{"start":{"line":24,"column":1,"offset":1665},"end":{"line":28,"column":4,"offset":1729},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Inside the pages dir create an index.js file and give it a lovely h1 saying hello or whatever you like. We will remove this once we add our image upload component.","position":{"start":{"line":30,"column":1,"offset":1733},"end":{"line":30,"column":164,"offset":1896},"indent":[]}}],"position":{"start":{"line":30,"column":1,"offset":1733},"end":{"line":30,"column":164,"offset":1896},"indent":[]}},{"type":"code","lang":"jsx","meta":null,"value":"import React from \"react\";\n\nexport default () => {\n  return <h1>Hello!</h1>;\n};","position":{"start":{"line":32,"column":1,"offset":1900},"end":{"line":38,"column":4,"offset":1996},"indent":[1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Before we move on nows the time to create you free Cloudinary account if you don't already have one. You will need to grab your cloud name, API key and API secret. Theses are best stored as env variables so create a .env file at the projects root and add them.","position":{"start":{"line":40,"column":1,"offset":2000},"end":{"line":40,"column":261,"offset":2260},"indent":[]}}],"position":{"start":{"line":40,"column":1,"offset":2000},"end":{"line":40,"column":261,"offset":2260},"indent":[]}},{"type":"code","lang":null,"meta":null,"value":"CLOUDINARY_NAME=my-project\nCLOUDINARY_API_KEY=xxxxxxxxxxxxxxxxxx\nCLOUDINARY_API_SECRET=xxxxxxxxxxxxxxxxxxxxx","position":{"start":{"line":42,"column":1,"offset":2264},"end":{"line":46,"column":4,"offset":2384},"indent":[1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Netlify toml","position":{"start":{"line":48,"column":4,"offset":2391},"end":{"line":48,"column":16,"offset":2403},"indent":[]}}],"position":{"start":{"line":48,"column":1,"offset":2388},"end":{"line":48,"column":16,"offset":2403},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Create a netlify.toml file at the projects root adding the following. This will tell netlify where to look for our function and how to run it.","position":{"start":{"line":50,"column":1,"offset":2407},"end":{"line":50,"column":143,"offset":2549},"indent":[]}}],"position":{"start":{"line":50,"column":1,"offset":2407},"end":{"line":50,"column":143,"offset":2549},"indent":[]}},{"type":"code","lang":"toml","meta":null,"value":"[build]\n  command = \"yarn build\"\n  functions = \"functions\"\n  publish = \"public\"","position":{"start":{"line":52,"column":1,"offset":2553},"end":{"line":57,"column":4,"offset":2649},"indent":[1,1,1,1,1]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Serverless function","position":{"start":{"line":59,"column":4,"offset":2656},"end":{"line":59,"column":23,"offset":2675},"indent":[]}}],"position":{"start":{"line":59,"column":1,"offset":2653},"end":{"line":59,"column":23,"offset":2675},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Now that we have that done we can create our serverless function which will do the leg work or uploading our images to our Cloudinary account. Begin by creating a new file inside the functions folder called upload.js. We'll then add our serverless function. You can check out the awesome ","position":{"start":{"line":61,"column":1,"offset":2679},"end":{"line":61,"column":289,"offset":2967},"indent":[]}},{"type":"link","title":null,"url":"https://use-cloudinary.netlify.app/usage/use-upload","children":[{"type":"text","value":"use-cloudinary docs","position":{"start":{"line":61,"column":290,"offset":2968},"end":{"line":61,"column":309,"offset":2987},"indent":[]}}],"position":{"start":{"line":61,"column":289,"offset":2967},"end":{"line":61,"column":363,"offset":3041},"indent":[]}},{"type":"text","value":", this is taken directly from them and work like a charm.","position":{"start":{"line":61,"column":363,"offset":3041},"end":{"line":61,"column":420,"offset":3098},"indent":[]}}],"position":{"start":{"line":61,"column":1,"offset":2679},"end":{"line":61,"column":420,"offset":3098},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"const cloudinary = require(\"cloudinary\").v2;\nconst dotenv = require(\"dotenv\");\ndotenv.config();\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET\n});\n\n// When doing a signed upload, you'll use a function like this\nexports.handler = async event => {\n  const { file } = JSON.parse(event.body);\n  const res = await cloudinary.uploader.upload(file, { ...JSON.parse(event.body) });\n  return {\n    statusCode: 200,\n    body: JSON.stringify(res)\n  };\n};","position":{"start":{"line":63,"column":1,"offset":3102},"end":{"line":83,"column":4,"offset":3683},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"The hook we will use will help us in transforming our image to our liking, our serverless function is accepting the event params that we will send it, parsing and destructuring the the file then adding the file and spreading the rest of the body to the Cloudinary uploader function, which comes from the cloudinary package. This will make more sense once we write our component to use this function.","position":{"start":{"line":85,"column":1,"offset":3687},"end":{"line":85,"column":400,"offset":4086},"indent":[]}}],"position":{"start":{"line":85,"column":1,"offset":3687},"end":{"line":85,"column":400,"offset":4086},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"useUpload","position":{"start":{"line":87,"column":4,"offset":4093},"end":{"line":87,"column":13,"offset":4102},"indent":[]}}],"position":{"start":{"line":87,"column":1,"offset":4090},"end":{"line":87,"column":13,"offset":4102},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Inside the components dir create a new file called image-upload.js. Here we will use the useUpload hook as well as the react dropzone input. The useUpload hook comes with some handle states which will be familiar to those of you that have used Apollo before. Let's take a look at the code then destructure whats going on.","position":{"start":{"line":89,"column":1,"offset":4106},"end":{"line":89,"column":322,"offset":4427},"indent":[]}}],"position":{"start":{"line":89,"column":1,"offset":4106},"end":{"line":89,"column":322,"offset":4427},"indent":[]}},{"type":"code","lang":"jsx","meta":null,"value":"import React from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useUpload } from \"use-cloudinary\";\n\nconst ImageUpload = ({ getUploadedProfileImage }) => {\n  const { upload, data, isLoading, isError, error } = useUpload({ endpoint: \"/.netlify/functions/upload\" });\n\n  const onDrop = React.useCallback(acceptedFiles => {\n    // Turn the blob into base64 to feed into the upload\n    const blobToBase64 = blob => {\n      const reader = new FileReader();\n      reader.readAsDataURL(blob);\n      return new Promise(resolve => {\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n      });\n    };\n\n    blobToBase64(acceptedFiles[0]).then(res => {\n      return upload({\n        // We pass the whole base64 string including the data:image tag\n        file: res,\n        uploadOptions: {\n          // Create a folder for our new image to live in\n          public_id: `my-cool-pics/${acceptedFiles[0].path}`,\n          tags: [],\n          // Manipulate our images size and crop\n          eager: [\n            {\n              width: 400,\n              height: 400,\n              crop: \"fill\"\n            }\n          ]\n        }\n      });\n    });\n  }, []);\n\n  React.useEffect(() => {\n    if (data && data.url) {\n      getUploadedProfileImage(data.url);\n    }\n  }, [data]);\n\n  const { getRootProps, getInputProps, acceptedFiles } = useDropzone({\n    onDrop,\n    accept: \"image/jpeg, image/png, image/PNG\"\n  });\n\n  if (isLoading)\n    return (\n      <div>\n        <p>Loading.....</p>\n      </div>\n    );\n\n  return (\n    <div {...getRootProps()}>\n      <input {...getInputProps()} />\n      <>\n        <div>\n          <p>Drag 'n' drop a profile image here, or click to select</p>\n          <em>(Only *.jpeg and *.png images will be accepted)</em>\n        </div>\n        {data ? (\n          <aside>\n            <h4>File:</h4>\n            <div>\n              <p>{acceptedFiles[0].path}</p>\n              <p>{acceptedFiles[0].size} Bytes</p>\n            </div>\n          </aside>\n        ) : null}\n\n        {isError ? <p>{error.message}</p> : null}\n      </>\n    </div>\n  );\n};\n\nexport default ImageUpload;","position":{"start":{"line":91,"column":1,"offset":4431},"end":{"line":175,"column":4,"offset":6658},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Beginning with the useUpload hook, we pass it our endpoint which the path to our serverless function. From this hook we can get the upload function, the returned data, two states (isLoading and isError) and any errors that may occur during the upload.","position":{"start":{"line":177,"column":1,"offset":6662},"end":{"line":177,"column":252,"offset":6913},"indent":[]}}],"position":{"start":{"line":177,"column":1,"offset":6662},"end":{"line":177,"column":252,"offset":6913},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Next we have a useCallback hook which handles the actual nitty gritty of the upload and file transformation. According to the libraries docs the file we upload can be:","position":{"start":{"line":179,"column":1,"offset":6917},"end":{"line":179,"column":168,"offset":7084},"indent":[]}}],"position":{"start":{"line":179,"column":1,"offset":6917},"end":{"line":179,"column":168,"offset":7084},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A local file path","position":{"start":{"line":181,"column":3,"offset":7090},"end":{"line":181,"column":20,"offset":7107},"indent":[]}}],"position":{"start":{"line":181,"column":3,"offset":7090},"end":{"line":181,"column":20,"offset":7107},"indent":[]}}],"position":{"start":{"line":181,"column":1,"offset":7088},"end":{"line":181,"column":20,"offset":7107},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A byte array buffer","position":{"start":{"line":182,"column":3,"offset":7111},"end":{"line":182,"column":22,"offset":7130},"indent":[]}}],"position":{"start":{"line":182,"column":3,"offset":7111},"end":{"line":182,"column":22,"offset":7130},"indent":[]}}],"position":{"start":{"line":182,"column":1,"offset":7109},"end":{"line":182,"column":22,"offset":7130},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A base64 encoded string which has a max of 60MB","position":{"start":{"line":183,"column":3,"offset":7134},"end":{"line":183,"column":50,"offset":7181},"indent":[]}}],"position":{"start":{"line":183,"column":3,"offset":7134},"end":{"line":183,"column":50,"offset":7181},"indent":[]}}],"position":{"start":{"line":183,"column":1,"offset":7132},"end":{"line":183,"column":50,"offset":7181},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"Remote FTP, HTTP or HTTPS URL address","position":{"start":{"line":184,"column":3,"offset":7185},"end":{"line":184,"column":40,"offset":7222},"indent":[]}}],"position":{"start":{"line":184,"column":3,"offset":7185},"end":{"line":184,"column":40,"offset":7222},"indent":[]}}],"position":{"start":{"line":184,"column":1,"offset":7183},"end":{"line":184,"column":40,"offset":7222},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A private storage bucket such as S3 from Amazon","position":{"start":{"line":185,"column":3,"offset":7226},"end":{"line":185,"column":50,"offset":7273},"indent":[]}}],"position":{"start":{"line":185,"column":3,"offset":7226},"end":{"line":185,"column":50,"offset":7273},"indent":[]}}],"position":{"start":{"line":185,"column":1,"offset":7224},"end":{"line":185,"column":50,"offset":7273},"indent":[]}}],"position":{"start":{"line":181,"column":1,"offset":7088},"end":{"line":185,"column":50,"offset":7273},"indent":[1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Our implementation uses the base64 encoded string. The useCallback hook is passed in an acceptedFiles array. First we create a utility function which takes the blob and converts it to a base64 string using the FileReader. We then use that function, passing in the first index of our acceptedFiles array. from the result we return the upload function from the useUpload hook. We pass our result as the file type, which is now a base64 encoded string. Our uploadOptions are how we want to manipulate our image. One gotcha here is that the function is expecting a tags array so be sure to add that, as well as the eager array, even if you are not adding any values to these.","position":{"start":{"line":187,"column":1,"offset":7277},"end":{"line":187,"column":672,"offset":7948},"indent":[]}}],"position":{"start":{"line":187,"column":1,"offset":7277},"end":{"line":187,"column":672,"offset":7948},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"When uploading an image dynamically to our Cloudinary account we can create a folder on the fly by adding a name for our folder as the initial value to the public_id, the value after the slash is our files path name. This will save our image in a folder called my-cool-pics. Using a function that we pass in as a prop to return the resulting image upload we use an useEffect hook which will run whenever the data object returned form the useUpload hook as changed. Inside the useEffect we check if the data object has a value and if its url is present, if it is then it means our upload was successful and we pass the image url on to our parent component.","position":{"start":{"line":189,"column":1,"offset":7952},"end":{"line":189,"column":656,"offset":8607},"indent":[]}}],"position":{"start":{"line":189,"column":1,"offset":7952},"end":{"line":189,"column":656,"offset":8607},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Before we render our component we call the useDropzone hook, passing in our onDrop function created as a useCallback, as well as specifying what image formats we would like to accept.","position":{"start":{"line":191,"column":1,"offset":8611},"end":{"line":191,"column":184,"offset":8794},"indent":[]}}],"position":{"start":{"line":191,"column":1,"offset":8611},"end":{"line":191,"column":184,"offset":8794},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Upload our image","position":{"start":{"line":193,"column":4,"offset":8801},"end":{"line":193,"column":20,"offset":8817},"indent":[]}}],"position":{"start":{"line":193,"column":1,"offset":8798},"end":{"line":193,"column":20,"offset":8817},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can now import our new ImageUpload component into our index page.","position":{"start":{"line":195,"column":1,"offset":8821},"end":{"line":195,"column":69,"offset":8889},"indent":[]}}],"position":{"start":{"line":195,"column":1,"offset":8821},"end":{"line":195,"column":69,"offset":8889},"indent":[]}},{"type":"code","lang":"jsx","meta":null,"value":"import React from \"react\";\nimport ImageUpload from \"../components/image-upload\";\n\nexport default () => {\n  const [uploadedProfileImage, setUploadedProfileImage] = React.useState(\"\");\n\n  const getUploadedProfileImage = image => {\n    if (image !== \"\") {\n      setUploadedProfileImage(image);\n    }\n  };\n\n  return (\n    <div>\n      <ImageUpload getUploadedProfileImage={getUploadedProfileImage} />\n      {uploadedProfileImage !== \"\" ? <img src={uploadedProfileImage} /> : null}\n    </div>\n  );\n};","position":{"start":{"line":197,"column":1,"offset":8893},"end":{"line":217,"column":4,"offset":9418},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"jsx","value":"<AccentBox>\n  Of course seeing as we are using Gatsby we should really be taking advantage of the awesome power of gatsby-image but\n  that is beyond the scope of this article.\n</AccentBox>","position":{"start":{"line":219,"column":1,"offset":9422},"end":{"line":222,"column":13,"offset":9613},"indent":[1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"You can now use the netlify-cli and run netlify dev and check that everything is working...","position":{"start":{"line":224,"column":1,"offset":9617},"end":{"line":224,"column":92,"offset":9708},"indent":[]}}],"position":{"start":{"line":224,"column":1,"offset":9617},"end":{"line":224,"column":92,"offset":9708},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"use-cloudinary - useUpload hook\",\"date\":\"2020-07-29T00:00:00.000Z\",\"published\":true,\"category\":\"First Look\",\"author\":\"Richard Haines\",\"keywords\":[\"use-cloudinary\",\"react hooks\",\"react-dropzone\"],\"pin\":false}","position":{"start":{"line":227,"column":1,"offset":9712},"end":{"line":227,"column":246,"offset":9957},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":227,"column":246,"offset":9957}}},"scopeImports":["import AccentBox from \"../src/components/site/blog/accent-box.js\";","import React from 'react'"],"scopeIdentifiers":["AccentBox","React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"use-cloudinary - useUpload hook\",\n  \"date\": \"2020-07-29T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"First Look\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"use-cloudinary\", \"react hooks\", \"react-dropzone\"],\n  \"pin\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Cloudinary is a great resource for handling and managing your images, with dynamic query string manipulation of the images you can deliver optimized, pictures to fit any applications needs. I've dabbled with it before but never really needed it in a project before. That was until I found myself with a real use case, to allow users to upload and store their social profile and cover photos in my latest project \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.devpack.dev/\"\n  }), \"devpack\"), \".\"), mdx(\"p\", null, \"I'd been made aware of a new hooks library built to harness the power of Cloudinary in React apps by it's creator \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://twitter.com/domitriusclark\"\n  }), \"Domitrius Clark\"), \", a dev rel at Cloudinary. Excited to try this new library out I combined it with an easy to use image dropzone package called \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://react-dropzone.js.org/\"\n  }), \"react-dropzone\"), \" and serverless functions. Having hit a few early snags, Dom was super helpful in getting me setup and on the correct path with how to use the lib! Now, shall we build something? LETS GOOOOOOOOOO! \\uD83D\\uDE1C\"), mdx(AccentBox, {\n    mdxType: \"AccentBox\"\n  }, \"This article assumes some prior knowledge of React, React hooks and Gatsby. It wont be covering version control or Netlify site setup.\"), mdx(\"h2\", {\n    \"id\": \"setup\"\n  }, \"Setup\"), mdx(\"p\", null, \"Let's do a clean install of Gatsby to get things up and running. You'll need a Netlify account also so that we can run the netlify-cli to locally check our serverless function is working correctly. Create a new folder which will house your project.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"yarn init -y\\nyarn add react react-dom gatsby netlify-cli use-cloudinary cloudinary react-dropzone dotenv\\n\")), mdx(\"p\", null, \"Add some default folders and files.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"mkdir src/pages\\nmkdir src/components\\nmkdir functions\\n\")), mdx(\"p\", null, \"Inside the pages dir create an index.js file and give it a lovely h1 saying hello or whatever you like. We will remove this once we add our image upload component.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from \\\"react\\\";\\n\\nexport default () => {\\n  return <h1>Hello!</h1>;\\n};\\n\")), mdx(\"p\", null, \"Before we move on nows the time to create you free Cloudinary account if you don't already have one. You will need to grab your cloud name, API key and API secret. Theses are best stored as env variables so create a .env file at the projects root and add them.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"CLOUDINARY_NAME=my-project\\nCLOUDINARY_API_KEY=xxxxxxxxxxxxxxxxxx\\nCLOUDINARY_API_SECRET=xxxxxxxxxxxxxxxxxxxxx\\n\")), mdx(\"h2\", {\n    \"id\": \"netlify-toml\"\n  }, \"Netlify toml\"), mdx(\"p\", null, \"Create a netlify.toml file at the projects root adding the following. This will tell netlify where to look for our function and how to run it.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-toml\"\n  }), \"[build]\\n  command = \\\"yarn build\\\"\\n  functions = \\\"functions\\\"\\n  publish = \\\"public\\\"\\n\")), mdx(\"h2\", {\n    \"id\": \"serverless-function\"\n  }, \"Serverless function\"), mdx(\"p\", null, \"Now that we have that done we can create our serverless function which will do the leg work or uploading our images to our Cloudinary account. Begin by creating a new file inside the functions folder called upload.js. We'll then add our serverless function. You can check out the awesome \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://use-cloudinary.netlify.app/usage/use-upload\"\n  }), \"use-cloudinary docs\"), \", this is taken directly from them and work like a charm.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const cloudinary = require(\\\"cloudinary\\\").v2;\\nconst dotenv = require(\\\"dotenv\\\");\\ndotenv.config();\\n\\ncloudinary.config({\\n  cloud_name: process.env.CLOUDINARY_NAME,\\n  api_key: process.env.CLOUDINARY_API_KEY,\\n  api_secret: process.env.CLOUDINARY_API_SECRET\\n});\\n\\n// When doing a signed upload, you'll use a function like this\\nexports.handler = async event => {\\n  const { file } = JSON.parse(event.body);\\n  const res = await cloudinary.uploader.upload(file, { ...JSON.parse(event.body) });\\n  return {\\n    statusCode: 200,\\n    body: JSON.stringify(res)\\n  };\\n};\\n\")), mdx(\"p\", null, \"The hook we will use will help us in transforming our image to our liking, our serverless function is accepting the event params that we will send it, parsing and destructuring the the file then adding the file and spreading the rest of the body to the Cloudinary uploader function, which comes from the cloudinary package. This will make more sense once we write our component to use this function.\"), mdx(\"h2\", {\n    \"id\": \"useupload\"\n  }, \"useUpload\"), mdx(\"p\", null, \"Inside the components dir create a new file called image-upload.js. Here we will use the useUpload hook as well as the react dropzone input. The useUpload hook comes with some handle states which will be familiar to those of you that have used Apollo before. Let's take a look at the code then destructure whats going on.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from \\\"react\\\";\\nimport { useDropzone } from \\\"react-dropzone\\\";\\nimport { useUpload } from \\\"use-cloudinary\\\";\\n\\nconst ImageUpload = ({ getUploadedProfileImage }) => {\\n  const { upload, data, isLoading, isError, error } = useUpload({ endpoint: \\\"/.netlify/functions/upload\\\" });\\n\\n  const onDrop = React.useCallback(acceptedFiles => {\\n    // Turn the blob into base64 to feed into the upload\\n    const blobToBase64 = blob => {\\n      const reader = new FileReader();\\n      reader.readAsDataURL(blob);\\n      return new Promise(resolve => {\\n        reader.onloadend = () => {\\n          resolve(reader.result);\\n        };\\n      });\\n    };\\n\\n    blobToBase64(acceptedFiles[0]).then(res => {\\n      return upload({\\n        // We pass the whole base64 string including the data:image tag\\n        file: res,\\n        uploadOptions: {\\n          // Create a folder for our new image to live in\\n          public_id: `my-cool-pics/${acceptedFiles[0].path}`,\\n          tags: [],\\n          // Manipulate our images size and crop\\n          eager: [\\n            {\\n              width: 400,\\n              height: 400,\\n              crop: \\\"fill\\\"\\n            }\\n          ]\\n        }\\n      });\\n    });\\n  }, []);\\n\\n  React.useEffect(() => {\\n    if (data && data.url) {\\n      getUploadedProfileImage(data.url);\\n    }\\n  }, [data]);\\n\\n  const { getRootProps, getInputProps, acceptedFiles } = useDropzone({\\n    onDrop,\\n    accept: \\\"image/jpeg, image/png, image/PNG\\\"\\n  });\\n\\n  if (isLoading)\\n    return (\\n      <div>\\n        <p>Loading.....</p>\\n      </div>\\n    );\\n\\n  return (\\n    <div {...getRootProps()}>\\n      <input {...getInputProps()} />\\n      <>\\n        <div>\\n          <p>Drag 'n' drop a profile image here, or click to select</p>\\n          <em>(Only *.jpeg and *.png images will be accepted)</em>\\n        </div>\\n        {data ? (\\n          <aside>\\n            <h4>File:</h4>\\n            <div>\\n              <p>{acceptedFiles[0].path}</p>\\n              <p>{acceptedFiles[0].size} Bytes</p>\\n            </div>\\n          </aside>\\n        ) : null}\\n\\n        {isError ? <p>{error.message}</p> : null}\\n      </>\\n    </div>\\n  );\\n};\\n\\nexport default ImageUpload;\\n\")), mdx(\"p\", null, \"Beginning with the useUpload hook, we pass it our endpoint which the path to our serverless function. From this hook we can get the upload function, the returned data, two states (isLoading and isError) and any errors that may occur during the upload.\"), mdx(\"p\", null, \"Next we have a useCallback hook which handles the actual nitty gritty of the upload and file transformation. According to the libraries docs the file we upload can be:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A local file path\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A byte array buffer\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A base64 encoded string which has a max of 60MB\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Remote FTP, HTTP or HTTPS URL address\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A private storage bucket such as S3 from Amazon\")), mdx(\"p\", null, \"Our implementation uses the base64 encoded string. The useCallback hook is passed in an acceptedFiles array. First we create a utility function which takes the blob and converts it to a base64 string using the FileReader. We then use that function, passing in the first index of our acceptedFiles array. from the result we return the upload function from the useUpload hook. We pass our result as the file type, which is now a base64 encoded string. Our uploadOptions are how we want to manipulate our image. One gotcha here is that the function is expecting a tags array so be sure to add that, as well as the eager array, even if you are not adding any values to these.\"), mdx(\"p\", null, \"When uploading an image dynamically to our Cloudinary account we can create a folder on the fly by adding a name for our folder as the initial value to the public_id, the value after the slash is our files path name. This will save our image in a folder called my-cool-pics. Using a function that we pass in as a prop to return the resulting image upload we use an useEffect hook which will run whenever the data object returned form the useUpload hook as changed. Inside the useEffect we check if the data object has a value and if its url is present, if it is then it means our upload was successful and we pass the image url on to our parent component.\"), mdx(\"p\", null, \"Before we render our component we call the useDropzone hook, passing in our onDrop function created as a useCallback, as well as specifying what image formats we would like to accept.\"), mdx(\"h2\", {\n    \"id\": \"upload-our-image\"\n  }, \"Upload our image\"), mdx(\"p\", null, \"We can now import our new ImageUpload component into our index page.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from \\\"react\\\";\\nimport ImageUpload from \\\"../components/image-upload\\\";\\n\\nexport default () => {\\n  const [uploadedProfileImage, setUploadedProfileImage] = React.useState(\\\"\\\");\\n\\n  const getUploadedProfileImage = image => {\\n    if (image !== \\\"\\\") {\\n      setUploadedProfileImage(image);\\n    }\\n  };\\n\\n  return (\\n    <div>\\n      <ImageUpload getUploadedProfileImage={getUploadedProfileImage} />\\n      {uploadedProfileImage !== \\\"\\\" ? <img src={uploadedProfileImage} /> : null}\\n    </div>\\n  );\\n};\\n\")), mdx(AccentBox, {\n    mdxType: \"AccentBox\"\n  }, \"Of course seeing as we are using Gatsby we should really be taking advantage of the awesome power of gatsby-image but that is beyond the scope of this article.\"), mdx(\"p\", null, \"You can now use the netlify-cli and run netlify dev and check that everything is working...\"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport AccentBox from \"../src/components/site/blog/accent-box.js\";\nexport const _frontmatter = {\n  \"title\": \"use-cloudinary - useUpload hook\",\n  \"date\": \"2020-07-29T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"First Look\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"use-cloudinary\", \"react hooks\", \"react-dropzone\"],\n  \"pin\": false\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`Cloudinary is a great resource for handling and managing your images, with dynamic query string manipulation of the images you can deliver optimized, pictures to fit any applications needs. I've dabbled with it before but never really needed it in a project before. That was until I found myself with a real use case, to allow users to upload and store their social profile and cover photos in my latest project `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.devpack.dev/\"\n      }}>{`devpack`}</a>{`.`}</p>\n    <p>{`I'd been made aware of a new hooks library built to harness the power of Cloudinary in React apps by it's creator `}<a parentName=\"p\" {...{\n        \"href\": \"https://twitter.com/domitriusclark\"\n      }}>{`Domitrius Clark`}</a>{`, a dev rel at Cloudinary. Excited to try this new library out I combined it with an easy to use image dropzone package called `}<a parentName=\"p\" {...{\n        \"href\": \"https://react-dropzone.js.org/\"\n      }}>{`react-dropzone`}</a>{` and serverless functions. Having hit a few early snags, Dom was super helpful in getting me setup and on the correct path with how to use the lib! Now, shall we build something? LETS GOOOOOOOOOO! ðŸ˜œ`}</p>\n    <AccentBox mdxType=\"AccentBox\">\n  This article assumes some prior knowledge of React, React hooks and Gatsby. It wont be covering version control or\n  Netlify site setup.\n    </AccentBox>\n    <h2 {...{\n      \"id\": \"setup\"\n    }}>{`Setup`}</h2>\n    <p>{`Let's do a clean install of Gatsby to get things up and running. You'll need a Netlify account also so that we can run the netlify-cli to locally check our serverless function is working correctly. Create a new folder which will house your project.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`yarn init -y\nyarn add react react-dom gatsby netlify-cli use-cloudinary cloudinary react-dropzone dotenv\n`}</code></pre>\n    <p>{`Add some default folders and files.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`mkdir src/pages\nmkdir src/components\nmkdir functions\n`}</code></pre>\n    <p>{`Inside the pages dir create an index.js file and give it a lovely h1 saying hello or whatever you like. We will remove this once we add our image upload component.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\";\n\nexport default () => {\n  return <h1>Hello!</h1>;\n};\n`}</code></pre>\n    <p>{`Before we move on nows the time to create you free Cloudinary account if you don't already have one. You will need to grab your cloud name, API key and API secret. Theses are best stored as env variables so create a .env file at the projects root and add them.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`CLOUDINARY_NAME=my-project\nCLOUDINARY_API_KEY=xxxxxxxxxxxxxxxxxx\nCLOUDINARY_API_SECRET=xxxxxxxxxxxxxxxxxxxxx\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"netlify-toml\"\n    }}>{`Netlify toml`}</h2>\n    <p>{`Create a netlify.toml file at the projects root adding the following. This will tell netlify where to look for our function and how to run it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-toml\"\n      }}>{`[build]\n  command = \"yarn build\"\n  functions = \"functions\"\n  publish = \"public\"\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"serverless-function\"\n    }}>{`Serverless function`}</h2>\n    <p>{`Now that we have that done we can create our serverless function which will do the leg work or uploading our images to our Cloudinary account. Begin by creating a new file inside the functions folder called upload.js. We'll then add our serverless function. You can check out the awesome `}<a parentName=\"p\" {...{\n        \"href\": \"https://use-cloudinary.netlify.app/usage/use-upload\"\n      }}>{`use-cloudinary docs`}</a>{`, this is taken directly from them and work like a charm.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const cloudinary = require(\"cloudinary\").v2;\nconst dotenv = require(\"dotenv\");\ndotenv.config();\n\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET\n});\n\n// When doing a signed upload, you'll use a function like this\nexports.handler = async event => {\n  const { file } = JSON.parse(event.body);\n  const res = await cloudinary.uploader.upload(file, { ...JSON.parse(event.body) });\n  return {\n    statusCode: 200,\n    body: JSON.stringify(res)\n  };\n};\n`}</code></pre>\n    <p>{`The hook we will use will help us in transforming our image to our liking, our serverless function is accepting the event params that we will send it, parsing and destructuring the the file then adding the file and spreading the rest of the body to the Cloudinary uploader function, which comes from the cloudinary package. This will make more sense once we write our component to use this function.`}</p>\n    <h2 {...{\n      \"id\": \"useupload\"\n    }}>{`useUpload`}</h2>\n    <p>{`Inside the components dir create a new file called image-upload.js. Here we will use the useUpload hook as well as the react dropzone input. The useUpload hook comes with some handle states which will be familiar to those of you that have used Apollo before. Let's take a look at the code then destructure whats going on.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport { useUpload } from \"use-cloudinary\";\n\nconst ImageUpload = ({ getUploadedProfileImage }) => {\n  const { upload, data, isLoading, isError, error } = useUpload({ endpoint: \"/.netlify/functions/upload\" });\n\n  const onDrop = React.useCallback(acceptedFiles => {\n    // Turn the blob into base64 to feed into the upload\n    const blobToBase64 = blob => {\n      const reader = new FileReader();\n      reader.readAsDataURL(blob);\n      return new Promise(resolve => {\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n      });\n    };\n\n    blobToBase64(acceptedFiles[0]).then(res => {\n      return upload({\n        // We pass the whole base64 string including the data:image tag\n        file: res,\n        uploadOptions: {\n          // Create a folder for our new image to live in\n          public_id: \\`my-cool-pics/\\${acceptedFiles[0].path}\\`,\n          tags: [],\n          // Manipulate our images size and crop\n          eager: [\n            {\n              width: 400,\n              height: 400,\n              crop: \"fill\"\n            }\n          ]\n        }\n      });\n    });\n  }, []);\n\n  React.useEffect(() => {\n    if (data && data.url) {\n      getUploadedProfileImage(data.url);\n    }\n  }, [data]);\n\n  const { getRootProps, getInputProps, acceptedFiles } = useDropzone({\n    onDrop,\n    accept: \"image/jpeg, image/png, image/PNG\"\n  });\n\n  if (isLoading)\n    return (\n      <div>\n        <p>Loading.....</p>\n      </div>\n    );\n\n  return (\n    <div {...getRootProps()}>\n      <input {...getInputProps()} />\n      <>\n        <div>\n          <p>Drag 'n' drop a profile image here, or click to select</p>\n          <em>(Only *.jpeg and *.png images will be accepted)</em>\n        </div>\n        {data ? (\n          <aside>\n            <h4>File:</h4>\n            <div>\n              <p>{acceptedFiles[0].path}</p>\n              <p>{acceptedFiles[0].size} Bytes</p>\n            </div>\n          </aside>\n        ) : null}\n\n        {isError ? <p>{error.message}</p> : null}\n      </>\n    </div>\n  );\n};\n\nexport default ImageUpload;\n`}</code></pre>\n    <p>{`Beginning with the useUpload hook, we pass it our endpoint which the path to our serverless function. From this hook we can get the upload function, the returned data, two states (isLoading and isError) and any errors that may occur during the upload.`}</p>\n    <p>{`Next we have a useCallback hook which handles the actual nitty gritty of the upload and file transformation. According to the libraries docs the file we upload can be:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`A local file path`}</li>\n      <li parentName=\"ul\">{`A byte array buffer`}</li>\n      <li parentName=\"ul\">{`A base64 encoded string which has a max of 60MB`}</li>\n      <li parentName=\"ul\">{`Remote FTP, HTTP or HTTPS URL address`}</li>\n      <li parentName=\"ul\">{`A private storage bucket such as S3 from Amazon`}</li>\n    </ul>\n    <p>{`Our implementation uses the base64 encoded string. The useCallback hook is passed in an acceptedFiles array. First we create a utility function which takes the blob and converts it to a base64 string using the FileReader. We then use that function, passing in the first index of our acceptedFiles array. from the result we return the upload function from the useUpload hook. We pass our result as the file type, which is now a base64 encoded string. Our uploadOptions are how we want to manipulate our image. One gotcha here is that the function is expecting a tags array so be sure to add that, as well as the eager array, even if you are not adding any values to these.`}</p>\n    <p>{`When uploading an image dynamically to our Cloudinary account we can create a folder on the fly by adding a name for our folder as the initial value to the public_id, the value after the slash is our files path name. This will save our image in a folder called my-cool-pics. Using a function that we pass in as a prop to return the resulting image upload we use an useEffect hook which will run whenever the data object returned form the useUpload hook as changed. Inside the useEffect we check if the data object has a value and if its url is present, if it is then it means our upload was successful and we pass the image url on to our parent component.`}</p>\n    <p>{`Before we render our component we call the useDropzone hook, passing in our onDrop function created as a useCallback, as well as specifying what image formats we would like to accept.`}</p>\n    <h2 {...{\n      \"id\": \"upload-our-image\"\n    }}>{`Upload our image`}</h2>\n    <p>{`We can now import our new ImageUpload component into our index page.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from \"react\";\nimport ImageUpload from \"../components/image-upload\";\n\nexport default () => {\n  const [uploadedProfileImage, setUploadedProfileImage] = React.useState(\"\");\n\n  const getUploadedProfileImage = image => {\n    if (image !== \"\") {\n      setUploadedProfileImage(image);\n    }\n  };\n\n  return (\n    <div>\n      <ImageUpload getUploadedProfileImage={getUploadedProfileImage} />\n      {uploadedProfileImage !== \"\" ? <img src={uploadedProfileImage} /> : null}\n    </div>\n  );\n};\n`}</code></pre>\n    <AccentBox mdxType=\"AccentBox\">\n  Of course seeing as we are using Gatsby we should really be taking advantage of the awesome power of gatsby-image but\n  that is beyond the scope of this article.\n    </AccentBox>\n    <p>{`You can now use the netlify-cli and run netlify dev and check that everything is working...`}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}