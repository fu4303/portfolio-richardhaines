{"expireTime":9007200851906806000,"key":"gatsby-plugin-mdx-entire-payload-0ce7c531e97907ce1e2567a3e40ba71e-","val":{"mdast":{"type":"root","children":[{"type":"import","value":"import AccentBox from \"../src/components/site/blog/accent-box.js\";","position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":67,"offset":68},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"Following on from my article about the use-cloudinary useUpload hook - ","position":{"start":{"line":4,"column":1,"offset":72},"end":{"line":4,"column":72,"offset":143},"indent":[]}},{"type":"link","title":null,"url":"/use-cloudinary","children":[{"type":"text","value":"use-cloudinary - useUpload hook","position":{"start":{"line":4,"column":73,"offset":144},"end":{"line":4,"column":104,"offset":175},"indent":[]}}],"position":{"start":{"line":4,"column":72,"offset":143},"end":{"line":4,"column":122,"offset":193},"indent":[]}},{"type":"text","value":", this time we'll be taking a look at the useSearch hook, and its a powerful beast!","position":{"start":{"line":4,"column":122,"offset":193},"end":{"line":4,"column":205,"offset":276},"indent":[]}}],"position":{"start":{"line":4,"column":1,"offset":72},"end":{"line":4,"column":205,"offset":276},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"My use case is simple, I have users upload their profile and cover image to cloudinary via the useUpload hook in ","position":{"start":{"line":6,"column":1,"offset":280},"end":{"line":6,"column":114,"offset":393},"indent":[]}},{"type":"link","title":null,"url":"https://www.devpack.dev/","children":[{"type":"text","value":"devpack","position":{"start":{"line":6,"column":115,"offset":394},"end":{"line":6,"column":122,"offset":401},"indent":[]}}],"position":{"start":{"line":6,"column":114,"offset":393},"end":{"line":6,"column":149,"offset":428},"indent":[]}},{"type":"text","value":". Each image is saved to a corresponding folder with their name and a suffix of either cover or profile. When the user next logs in to devpack they can choose to upload their previous 3 images that were saved in their cloudinary folders, or just upload a new image and use that one.","position":{"start":{"line":6,"column":149,"offset":428},"end":{"line":6,"column":431,"offset":710},"indent":[]}}],"position":{"start":{"line":6,"column":1,"offset":280},"end":{"line":6,"column":431,"offset":710},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"This is where useSearch comes into play. I use it by calling a serverless function which I pass a search function with certain search parameters. Lets look at some code to get an idea of what Im talking about.","position":{"start":{"line":8,"column":1,"offset":714},"end":{"line":8,"column":210,"offset":923},"indent":[]}}],"position":{"start":{"line":8,"column":1,"offset":714},"end":{"line":8,"column":210,"offset":923},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Serverless function","position":{"start":{"line":10,"column":4,"offset":930},"end":{"line":10,"column":23,"offset":949},"indent":[]}}],"position":{"start":{"line":10,"column":1,"offset":927},"end":{"line":10,"column":23,"offset":949},"indent":[]}},{"type":"code","lang":"js","meta":null,"value":"const cloudinary = require('cloudinary').v2;\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\nexports.handler = async (event) => {\n  const body = JSON.parse(event.body);\n  const res = await cloudinary.search\n    .expression(body.expression)\n    .execute()\n    .then((result) => result);\n  return {\n    statusCode: 200,\n    body: JSON.stringify(res),\n  };\n};\n","position":{"start":{"line":12,"column":1,"offset":953},"end":{"line":31,"column":4,"offset":1451},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"This function takes an event, parses the body and calls the cloudinary search method. Its passed the search expression from the body and return an a ok 200.","position":{"start":{"line":33,"column":1,"offset":1455},"end":{"line":33,"column":157,"offset":1611},"indent":[]}}],"position":{"start":{"line":33,"column":1,"offset":1455},"end":{"line":33,"column":157,"offset":1611},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"useSearch","position":{"start":{"line":35,"column":4,"offset":1618},"end":{"line":35,"column":13,"offset":1627},"indent":[]}}],"position":{"start":{"line":35,"column":1,"offset":1615},"end":{"line":35,"column":13,"offset":1627},"indent":[]}},{"type":"blockquote","children":[{"type":"paragraph","children":[{"type":"text","value":"I've removed styles from this component","position":{"start":{"line":37,"column":3,"offset":1633},"end":{"line":37,"column":42,"offset":1672},"indent":[]}}],"position":{"start":{"line":37,"column":3,"offset":1633},"end":{"line":37,"column":42,"offset":1672},"indent":[]}}],"position":{"start":{"line":37,"column":1,"offset":1631},"end":{"line":37,"column":42,"offset":1672},"indent":[]}},{"type":"code","lang":"jsx","meta":null,"value":"import React from 'react';\nimport Button from './button';\nimport LazyImage from '../hub/dev-card/image';\nimport Error from '../svg/error';\nimport Loading from '../svg/loading';\nimport { useSearch } from 'use-cloudinary';\nimport { DevCardStateContext } from '../../context/devcard-context';\n\nconst SavedProfileImages = () => {\n  const { search, data, isLoading, isSuccess, isError, error } = useSearch({ endpoint: '/.netlify/functions/search' });\n\n  const state = React.useContext(DevCardStateContext);\n\n  const getFolder = () => {\n    if (state.cloudinaryFolderName !== '') {\n      return state.cloudinaryFolderName;\n    }\n    return state.name.replace(/\\s/g, '');\n  };\n\n  const customConfigSearch = React.useCallback(\n    () => search({ resourceType: 'image', folder: getFolder(), max_results: 3 }),\n    [search, getFolder()]\n  );\n\n  if (isLoading)\n    return <Loading />\n  if (isError)\n    return (\n      <div>\n        <Error width=\"90px\" height=\"90px\" />\n        <p>\n          {error.message}\n        </p>\n      </div>\n    );\n\n  if (getFolder() !== '' && isSuccess) {\n    return (\n      <div>\n        <div>\n          {data &&\n            data.resources\n              .filter((image) => image.folder === getFolder())\n              .slice(0, 3)\n              .map((image) => {\n                return (\n                  <LazyImage\n                    key={image.etag}\n                    publicId={image.public_id}\n                    width={100}\n                    height={100}\n                    transforms={{ height: 0.2, border: '2px_solid_black' }}\n                    cloudName=\"xxxxxxx\"\n                    secure_url={image.secure_url}\n                  />\n                );\n              })}\n        </div>\n        <em>\n          Your last 3 saves are shown\n        </em>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <Button text=\"Load Profile Images\" onClick={() => customConfigSearch()} />\n      <em>\n        Your last 3 saves are shown\n      </em>\n    </div>\n  );\n};\n\nexport default SavedProfileImages;","position":{"start":{"line":39,"column":1,"offset":1676},"end":{"line":117,"column":4,"offset":3791},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Lets break this down. ","position":{"start":{"line":119,"column":1,"offset":3795},"end":{"line":119,"column":23,"offset":3817},"indent":[]}}],"position":{"start":{"line":119,"column":1,"offset":3795},"end":{"line":119,"column":23,"offset":3817},"indent":[]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The useSearch hook takes an endpoint, in our case our serverless function. Its return a search function, the data and some states. ","position":{"start":{"line":121,"column":3,"offset":3823},"end":{"line":121,"column":134,"offset":3954},"indent":[]}}],"position":{"start":{"line":121,"column":3,"offset":3823},"end":{"line":121,"column":134,"offset":3954},"indent":[]}}],"position":{"start":{"line":121,"column":1,"offset":3821},"end":{"line":121,"column":134,"offset":3954},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The context holds both the users previous folder names or a manually entered one for this image. The getFolder function decides which folder to use.","position":{"start":{"line":122,"column":3,"offset":3958},"end":{"line":122,"column":151,"offset":4106},"indent":[]}}],"position":{"start":{"line":122,"column":3,"offset":3958},"end":{"line":122,"column":151,"offset":4106},"indent":[]}}],"position":{"start":{"line":122,"column":1,"offset":3956},"end":{"line":122,"column":151,"offset":4106},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The customConfigSearch is the power house of this functionality. You can pass it any number of things to search by, in our case its the folder and a max result of 3. Its wrapped in a useCallback to prevent re-rendering based on the prop changes and stop our serverless function being called again and again. This saves us on our rate limit with cloudinary. It takes the search function itself and the folder as this can be changed outside this component if the user decides to create their own folder manually.","position":{"start":{"line":123,"column":3,"offset":4110},"end":{"line":123,"column":513,"offset":4620},"indent":[]}}],"position":{"start":{"line":123,"column":3,"offset":4110},"end":{"line":123,"column":513,"offset":4620},"indent":[]}}],"position":{"start":{"line":123,"column":1,"offset":4108},"end":{"line":123,"column":513,"offset":4620},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The states are handled with custom error and loading components- If the folder is a match and the data was retrieved successfully then the data array is accessed","position":{"start":{"line":124,"column":3,"offset":4624},"end":{"line":124,"column":164,"offset":4785},"indent":[]}}],"position":{"start":{"line":124,"column":3,"offset":4624},"end":{"line":124,"column":164,"offset":4785},"indent":[]}}],"position":{"start":{"line":124,"column":1,"offset":4622},"end":{"line":124,"column":164,"offset":4785},"indent":[]}}],"position":{"start":{"line":121,"column":1,"offset":3821},"end":{"line":124,"column":164,"offset":4785},"indent":[1,1,1]}},{"type":"jsx","value":"<AccentBox>\n    At the time of writing the max_results doesn't seem to be working every time so a slice is used to make sure we return only the latest 3 results. Also the folder is confirmed. This notice is only here to point out the code snippet as you might be wondering why I've added the checks when I already passed the params to the search function.\n</AccentBox>","position":{"start":{"line":126,"column":1,"offset":4789},"end":{"line":128,"column":13,"offset":5159},"indent":[1,1]}},{"type":"list","ordered":false,"start":null,"spread":false,"children":[{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"The image is returned as a lazy image, which we will cover next!","position":{"start":{"line":130,"column":3,"offset":5165},"end":{"line":130,"column":67,"offset":5229},"indent":[]}}],"position":{"start":{"line":130,"column":3,"offset":5165},"end":{"line":130,"column":67,"offset":5229},"indent":[]}}],"position":{"start":{"line":130,"column":1,"offset":5163},"end":{"line":130,"column":67,"offset":5229},"indent":[]}},{"type":"listItem","spread":false,"checked":null,"children":[{"type":"paragraph","children":[{"type":"text","value":"A button calls the customConfigSearch function to load the images.","position":{"start":{"line":131,"column":3,"offset":5233},"end":{"line":131,"column":69,"offset":5299},"indent":[]}}],"position":{"start":{"line":131,"column":3,"offset":5233},"end":{"line":131,"column":69,"offset":5299},"indent":[]}}],"position":{"start":{"line":131,"column":1,"offset":5231},"end":{"line":131,"column":69,"offset":5299},"indent":[]}}],"position":{"start":{"line":130,"column":1,"offset":5163},"end":{"line":131,"column":69,"offset":5299},"indent":[1]}},{"type":"paragraph","children":[{"type":"text","value":"The lazy image is a component that lazy loads an image with a placeholder. Handy!","position":{"start":{"line":133,"column":1,"offset":5303},"end":{"line":133,"column":82,"offset":5384},"indent":[]}}],"position":{"start":{"line":133,"column":1,"offset":5303},"end":{"line":133,"column":82,"offset":5384},"indent":[]}},{"type":"heading","depth":2,"children":[{"type":"text","value":"Lazy load image","position":{"start":{"line":135,"column":4,"offset":5391},"end":{"line":135,"column":19,"offset":5406},"indent":[]}}],"position":{"start":{"line":135,"column":1,"offset":5388},"end":{"line":135,"column":19,"offset":5406},"indent":[]}},{"type":"code","lang":"jsx","meta":null,"value":"import React from 'react';\nimport { useImage } from 'use-cloudinary';\nimport { DevCardDispatchContext } from '../../../context/devcard-context';\n\n// Image w/ Lazy-load + placeholder\nfunction LazyImage({ publicId, transformations, width, height, cloudName, secure_url, isProfile }) {\n  const { generateUrl, blurredPlaceholderUrl, isError, error, ref, supportsLazyLoading, inView, isSuccess } = useImage({\n    cloudName,\n  });\n  const dispatch = React.useContext(DevCardDispatchContext);\n  React.useEffect(() => {\n    generateUrl({\n      publicId,\n      transformations: {\n        width,\n        height,\n        ...transformations,\n      },\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  if (isError) return <p>{error.message}</p>;\n  return (\n    <div\n      ref={!supportsLazyLoading ? ref : undefined}\n      style={{\n        width: `${width}px`,\n        height: `${height}px`,\n        background: `no-repeat url(${blurredPlaceholderUrl(publicId, width, height)})`,\n        cursor: 'pointer',\n        outline: 'none',\n      }}\n      role=\"button\"\n      tabindex=\"0\"\n      // aria-pressed=\"false\"\n      onKeyPress={() =>\n        dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })\n      }\n      onClick={() => dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })}\n    >\n      {inView || (supportsLazyLoading && isSuccess) ? (\n        <img\n          src={secure_url}\n          loading=\"lazy\"\n          style={{\n            width: `${width}px`,\n            height: `${height}px`,\n            border: 'solid 2px',\n          }}\n          alt=\"Lazy loaded profile\"\n        />\n      ) : null}\n    </div>\n  );\n}\n\nexport default LazyImage;\n","position":{"start":{"line":137,"column":1,"offset":5410},"end":{"line":196,"column":4,"offset":7236},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"One thing to note about using this component with Gatsby is that the base image url wont load the image, you have to use the https secure_url for it to work.","position":{"start":{"line":198,"column":1,"offset":7240},"end":{"line":198,"column":158,"offset":7397},"indent":[]}}],"position":{"start":{"line":198,"column":1,"offset":7240},"end":{"line":198,"column":158,"offset":7397},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"And thats it! It's a pretty powerful way to load your images via user defined events. Check the ","position":{"start":{"line":200,"column":1,"offset":7401},"end":{"line":200,"column":97,"offset":7497},"indent":[]}},{"type":"link","title":null,"url":"https://use-cloudinary.netlify.app/usage/use-search","children":[{"type":"text","value":"useSearch docs","position":{"start":{"line":200,"column":98,"offset":7498},"end":{"line":200,"column":112,"offset":7512},"indent":[]}}],"position":{"start":{"line":200,"column":97,"offset":7497},"end":{"line":200,"column":166,"offset":7566},"indent":[]}},{"type":"text","value":" for a run down of whats possible with the hook. ","position":{"start":{"line":200,"column":166,"offset":7566},"end":{"line":200,"column":215,"offset":7615},"indent":[]}}],"position":{"start":{"line":200,"column":1,"offset":7401},"end":{"line":200,"column":215,"offset":7615},"indent":[]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"use-cloudinary - useSearch\",\"date\":\"2020-08-11T00:00:00.000Z\",\"published\":true,\"category\":\"First Look\",\"author\":\"Richard Haines\",\"keywords\":[\"use-cloudinary\",\"react hooks\"],\"pin\":false}","position":{"start":{"line":202,"column":1,"offset":7617},"end":{"line":202,"column":224,"offset":7840},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":202,"column":224,"offset":7840}}},"scopeImports":["import AccentBox from \"../src/components/site/blog/accent-box.js\";","import React from 'react'"],"scopeIdentifiers":["AccentBox","React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"use-cloudinary - useSearch\",\n  \"date\": \"2020-08-11T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"First Look\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"use-cloudinary\", \"react hooks\"],\n  \"pin\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Following on from my article about the use-cloudinary useUpload hook - \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/use-cloudinary\"\n  }), \"use-cloudinary - useUpload hook\"), \", this time we'll be taking a look at the useSearch hook, and its a powerful beast!\"), mdx(\"p\", null, \"My use case is simple, I have users upload their profile and cover image to cloudinary via the useUpload hook in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.devpack.dev/\"\n  }), \"devpack\"), \". Each image is saved to a corresponding folder with their name and a suffix of either cover or profile. When the user next logs in to devpack they can choose to upload their previous 3 images that were saved in their cloudinary folders, or just upload a new image and use that one.\"), mdx(\"p\", null, \"This is where useSearch comes into play. I use it by calling a serverless function which I pass a search function with certain search parameters. Lets look at some code to get an idea of what Im talking about.\"), mdx(\"h2\", {\n    \"id\": \"serverless-function\"\n  }, \"Serverless function\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const cloudinary = require('cloudinary').v2;\\ncloudinary.config({\\n  cloud_name: process.env.CLOUDINARY_NAME,\\n  api_key: process.env.CLOUDINARY_API_KEY,\\n  api_secret: process.env.CLOUDINARY_API_SECRET,\\n});\\nexports.handler = async (event) => {\\n  const body = JSON.parse(event.body);\\n  const res = await cloudinary.search\\n    .expression(body.expression)\\n    .execute()\\n    .then((result) => result);\\n  return {\\n    statusCode: 200,\\n    body: JSON.stringify(res),\\n  };\\n};\\n\\n\")), mdx(\"p\", null, \"This function takes an event, parses the body and calls the cloudinary search method. Its passed the search expression from the body and return an a ok 200.\"), mdx(\"h2\", {\n    \"id\": \"usesearch\"\n  }, \"useSearch\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I've removed styles from this component\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from 'react';\\nimport Button from './button';\\nimport LazyImage from '../hub/dev-card/image';\\nimport Error from '../svg/error';\\nimport Loading from '../svg/loading';\\nimport { useSearch } from 'use-cloudinary';\\nimport { DevCardStateContext } from '../../context/devcard-context';\\n\\nconst SavedProfileImages = () => {\\n  const { search, data, isLoading, isSuccess, isError, error } = useSearch({ endpoint: '/.netlify/functions/search' });\\n\\n  const state = React.useContext(DevCardStateContext);\\n\\n  const getFolder = () => {\\n    if (state.cloudinaryFolderName !== '') {\\n      return state.cloudinaryFolderName;\\n    }\\n    return state.name.replace(/\\\\s/g, '');\\n  };\\n\\n  const customConfigSearch = React.useCallback(\\n    () => search({ resourceType: 'image', folder: getFolder(), max_results: 3 }),\\n    [search, getFolder()]\\n  );\\n\\n  if (isLoading)\\n    return <Loading />\\n  if (isError)\\n    return (\\n      <div>\\n        <Error width=\\\"90px\\\" height=\\\"90px\\\" />\\n        <p>\\n          {error.message}\\n        </p>\\n      </div>\\n    );\\n\\n  if (getFolder() !== '' && isSuccess) {\\n    return (\\n      <div>\\n        <div>\\n          {data &&\\n            data.resources\\n              .filter((image) => image.folder === getFolder())\\n              .slice(0, 3)\\n              .map((image) => {\\n                return (\\n                  <LazyImage\\n                    key={image.etag}\\n                    publicId={image.public_id}\\n                    width={100}\\n                    height={100}\\n                    transforms={{ height: 0.2, border: '2px_solid_black' }}\\n                    cloudName=\\\"xxxxxxx\\\"\\n                    secure_url={image.secure_url}\\n                  />\\n                );\\n              })}\\n        </div>\\n        <em>\\n          Your last 3 saves are shown\\n        </em>\\n      </div>\\n    );\\n  }\\n\\n  return (\\n    <div>\\n      <Button text=\\\"Load Profile Images\\\" onClick={() => customConfigSearch()} />\\n      <em>\\n        Your last 3 saves are shown\\n      </em>\\n    </div>\\n  );\\n};\\n\\nexport default SavedProfileImages;\\n\")), mdx(\"p\", null, \"Lets break this down. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The useSearch hook takes an endpoint, in our case our serverless function. Its return a search function, the data and some states. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The context holds both the users previous folder names or a manually entered one for this image. The getFolder function decides which folder to use.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The customConfigSearch is the power house of this functionality. You can pass it any number of things to search by, in our case its the folder and a max result of 3. Its wrapped in a useCallback to prevent re-rendering based on the prop changes and stop our serverless function being called again and again. This saves us on our rate limit with cloudinary. It takes the search function itself and the folder as this can be changed outside this component if the user decides to create their own folder manually.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The states are handled with custom error and loading components- If the folder is a match and the data was retrieved successfully then the data array is accessed\")), mdx(AccentBox, {\n    mdxType: \"AccentBox\"\n  }, \"At the time of writing the max_results doesn't seem to be working every time so a slice is used to make sure we return only the latest 3 results. Also the folder is confirmed. This notice is only here to point out the code snippet as you might be wondering why I've added the checks when I already passed the params to the search function.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The image is returned as a lazy image, which we will cover next!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A button calls the customConfigSearch function to load the images.\")), mdx(\"p\", null, \"The lazy image is a component that lazy loads an image with a placeholder. Handy!\"), mdx(\"h2\", {\n    \"id\": \"lazy-load-image\"\n  }, \"Lazy load image\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\"\n  }), \"import React from 'react';\\nimport { useImage } from 'use-cloudinary';\\nimport { DevCardDispatchContext } from '../../../context/devcard-context';\\n\\n// Image w/ Lazy-load + placeholder\\nfunction LazyImage({ publicId, transformations, width, height, cloudName, secure_url, isProfile }) {\\n  const { generateUrl, blurredPlaceholderUrl, isError, error, ref, supportsLazyLoading, inView, isSuccess } = useImage({\\n    cloudName,\\n  });\\n  const dispatch = React.useContext(DevCardDispatchContext);\\n  React.useEffect(() => {\\n    generateUrl({\\n      publicId,\\n      transformations: {\\n        width,\\n        height,\\n        ...transformations,\\n      },\\n    });\\n    // eslint-disable-next-line react-hooks/exhaustive-deps\\n  }, []);\\n  if (isError) return <p>{error.message}</p>;\\n  return (\\n    <div\\n      ref={!supportsLazyLoading ? ref : undefined}\\n      style={{\\n        width: `${width}px`,\\n        height: `${height}px`,\\n        background: `no-repeat url(${blurredPlaceholderUrl(publicId, width, height)})`,\\n        cursor: 'pointer',\\n        outline: 'none',\\n      }}\\n      role=\\\"button\\\"\\n      tabindex=\\\"0\\\"\\n      // aria-pressed=\\\"false\\\"\\n      onKeyPress={() =>\\n        dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })\\n      }\\n      onClick={() => dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })}\\n    >\\n      {inView || (supportsLazyLoading && isSuccess) ? (\\n        <img\\n          src={secure_url}\\n          loading=\\\"lazy\\\"\\n          style={{\\n            width: `${width}px`,\\n            height: `${height}px`,\\n            border: 'solid 2px',\\n          }}\\n          alt=\\\"Lazy loaded profile\\\"\\n        />\\n      ) : null}\\n    </div>\\n  );\\n}\\n\\nexport default LazyImage;\\n\\n\")), mdx(\"p\", null, \"One thing to note about using this component with Gatsby is that the base image url wont load the image, you have to use the https secure_url for it to work.\"), mdx(\"p\", null, \"And thats it! It's a pretty powerful way to load your images via user defined events. Check the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://use-cloudinary.netlify.app/usage/use-search\"\n  }), \"useSearch docs\"), \" for a run down of whats possible with the hook. \"));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\nimport AccentBox from \"../src/components/site/blog/accent-box.js\";\nexport const _frontmatter = {\n  \"title\": \"use-cloudinary - useSearch\",\n  \"date\": \"2020-08-11T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"First Look\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"use-cloudinary\", \"react hooks\"],\n  \"pin\": false\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <p>{`Following on from my article about the use-cloudinary useUpload hook - `}<a parentName=\"p\" {...{\n        \"href\": \"/use-cloudinary\"\n      }}>{`use-cloudinary - useUpload hook`}</a>{`, this time we'll be taking a look at the useSearch hook, and its a powerful beast!`}</p>\n    <p>{`My use case is simple, I have users upload their profile and cover image to cloudinary via the useUpload hook in `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.devpack.dev/\"\n      }}>{`devpack`}</a>{`. Each image is saved to a corresponding folder with their name and a suffix of either cover or profile. When the user next logs in to devpack they can choose to upload their previous 3 images that were saved in their cloudinary folders, or just upload a new image and use that one.`}</p>\n    <p>{`This is where useSearch comes into play. I use it by calling a serverless function which I pass a search function with certain search parameters. Lets look at some code to get an idea of what Im talking about.`}</p>\n    <h2 {...{\n      \"id\": \"serverless-function\"\n    }}>{`Serverless function`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const cloudinary = require('cloudinary').v2;\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\nexports.handler = async (event) => {\n  const body = JSON.parse(event.body);\n  const res = await cloudinary.search\n    .expression(body.expression)\n    .execute()\n    .then((result) => result);\n  return {\n    statusCode: 200,\n    body: JSON.stringify(res),\n  };\n};\n\n`}</code></pre>\n    <p>{`This function takes an event, parses the body and calls the cloudinary search method. Its passed the search expression from the body and return an a ok 200.`}</p>\n    <h2 {...{\n      \"id\": \"usesearch\"\n    }}>{`useSearch`}</h2>\n    <blockquote>\n      <p parentName=\"blockquote\">{`I've removed styles from this component`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from 'react';\nimport Button from './button';\nimport LazyImage from '../hub/dev-card/image';\nimport Error from '../svg/error';\nimport Loading from '../svg/loading';\nimport { useSearch } from 'use-cloudinary';\nimport { DevCardStateContext } from '../../context/devcard-context';\n\nconst SavedProfileImages = () => {\n  const { search, data, isLoading, isSuccess, isError, error } = useSearch({ endpoint: '/.netlify/functions/search' });\n\n  const state = React.useContext(DevCardStateContext);\n\n  const getFolder = () => {\n    if (state.cloudinaryFolderName !== '') {\n      return state.cloudinaryFolderName;\n    }\n    return state.name.replace(/\\\\s/g, '');\n  };\n\n  const customConfigSearch = React.useCallback(\n    () => search({ resourceType: 'image', folder: getFolder(), max_results: 3 }),\n    [search, getFolder()]\n  );\n\n  if (isLoading)\n    return <Loading />\n  if (isError)\n    return (\n      <div>\n        <Error width=\"90px\" height=\"90px\" />\n        <p>\n          {error.message}\n        </p>\n      </div>\n    );\n\n  if (getFolder() !== '' && isSuccess) {\n    return (\n      <div>\n        <div>\n          {data &&\n            data.resources\n              .filter((image) => image.folder === getFolder())\n              .slice(0, 3)\n              .map((image) => {\n                return (\n                  <LazyImage\n                    key={image.etag}\n                    publicId={image.public_id}\n                    width={100}\n                    height={100}\n                    transforms={{ height: 0.2, border: '2px_solid_black' }}\n                    cloudName=\"xxxxxxx\"\n                    secure_url={image.secure_url}\n                  />\n                );\n              })}\n        </div>\n        <em>\n          Your last 3 saves are shown\n        </em>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      <Button text=\"Load Profile Images\" onClick={() => customConfigSearch()} />\n      <em>\n        Your last 3 saves are shown\n      </em>\n    </div>\n  );\n};\n\nexport default SavedProfileImages;\n`}</code></pre>\n    <p>{`Lets break this down. `}</p>\n    <ul>\n      <li parentName=\"ul\">{`The useSearch hook takes an endpoint, in our case our serverless function. Its return a search function, the data and some states. `}</li>\n      <li parentName=\"ul\">{`The context holds both the users previous folder names or a manually entered one for this image. The getFolder function decides which folder to use.`}</li>\n      <li parentName=\"ul\">{`The customConfigSearch is the power house of this functionality. You can pass it any number of things to search by, in our case its the folder and a max result of 3. Its wrapped in a useCallback to prevent re-rendering based on the prop changes and stop our serverless function being called again and again. This saves us on our rate limit with cloudinary. It takes the search function itself and the folder as this can be changed outside this component if the user decides to create their own folder manually.`}</li>\n      <li parentName=\"ul\">{`The states are handled with custom error and loading components- If the folder is a match and the data was retrieved successfully then the data array is accessed`}</li>\n    </ul>\n    <AccentBox mdxType=\"AccentBox\">\n    At the time of writing the max_results doesn't seem to be working every time so a slice is used to make sure we return only the latest 3 results. Also the folder is confirmed. This notice is only here to point out the code snippet as you might be wondering why I've added the checks when I already passed the params to the search function.\n    </AccentBox>\n    <ul>\n      <li parentName=\"ul\">{`The image is returned as a lazy image, which we will cover next!`}</li>\n      <li parentName=\"ul\">{`A button calls the customConfigSearch function to load the images.`}</li>\n    </ul>\n    <p>{`The lazy image is a component that lazy loads an image with a placeholder. Handy!`}</p>\n    <h2 {...{\n      \"id\": \"lazy-load-image\"\n    }}>{`Lazy load image`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-jsx\"\n      }}>{`import React from 'react';\nimport { useImage } from 'use-cloudinary';\nimport { DevCardDispatchContext } from '../../../context/devcard-context';\n\n// Image w/ Lazy-load + placeholder\nfunction LazyImage({ publicId, transformations, width, height, cloudName, secure_url, isProfile }) {\n  const { generateUrl, blurredPlaceholderUrl, isError, error, ref, supportsLazyLoading, inView, isSuccess } = useImage({\n    cloudName,\n  });\n  const dispatch = React.useContext(DevCardDispatchContext);\n  React.useEffect(() => {\n    generateUrl({\n      publicId,\n      transformations: {\n        width,\n        height,\n        ...transformations,\n      },\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  if (isError) return <p>{error.message}</p>;\n  return (\n    <div\n      ref={!supportsLazyLoading ? ref : undefined}\n      style={{\n        width: \\`\\${width}px\\`,\n        height: \\`\\${height}px\\`,\n        background: \\`no-repeat url(\\${blurredPlaceholderUrl(publicId, width, height)})\\`,\n        cursor: 'pointer',\n        outline: 'none',\n      }}\n      role=\"button\"\n      tabindex=\"0\"\n      // aria-pressed=\"false\"\n      onKeyPress={() =>\n        dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })\n      }\n      onClick={() => dispatch({ type: isProfile ? 'selectedProfileImage' : 'selectedCoverImage', payload: secure_url })}\n    >\n      {inView || (supportsLazyLoading && isSuccess) ? (\n        <img\n          src={secure_url}\n          loading=\"lazy\"\n          style={{\n            width: \\`\\${width}px\\`,\n            height: \\`\\${height}px\\`,\n            border: 'solid 2px',\n          }}\n          alt=\"Lazy loaded profile\"\n        />\n      ) : null}\n    </div>\n  );\n}\n\nexport default LazyImage;\n\n`}</code></pre>\n    <p>{`One thing to note about using this component with Gatsby is that the base image url wont load the image, you have to use the https secure_url for it to work.`}</p>\n    <p>{`And thats it! It's a pretty powerful way to load your images via user defined events. Check the `}<a parentName=\"p\" {...{\n        \"href\": \"https://use-cloudinary.netlify.app/usage/use-search\"\n      }}>{`useSearch docs`}</a>{` for a run down of whats possible with the hook. `}</p>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}