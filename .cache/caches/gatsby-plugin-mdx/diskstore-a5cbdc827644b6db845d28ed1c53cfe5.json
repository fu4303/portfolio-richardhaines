{"expireTime":9007200851906807000,"key":"gatsby-plugin-mdx-entire-payload-d67eca09b7d1dd18e0e355cd75be1c6c-","val":{"mdast":{"type":"root","children":[{"type":"paragraph","children":[{"type":"text","value":"When we create a context using TypeScript the compiler expects us to provide a default value, usually, but not always, this is set to null or undefined. This is fine in a JavaScript project but when using TypeScript it means that we have to check for null or undefined every time we want to use the context. This is a helper hook that does the heavy lifting for us. ","position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":367,"offset":368},"indent":[]}}],"position":{"start":{"line":2,"column":1,"offset":2},"end":{"line":2,"column":367,"offset":368},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"function useCreateNoNullContext<T>(contextName: string) {\n    const context = React.createContext<T | undefined>(undefined);\n\n    function useNoNullContext() {\n        const noNullContext = React.useContext(context);\n        if (!noNullContext) {\n        throw new Error(`${contextName} must be used inside a provider with a value`);\n        }\n        return noNullContext;\n    }\n    return [useNoNullContext, context.Provider] as const;\n    }","position":{"start":{"line":4,"column":1,"offset":372},"end":{"line":17,"column":4,"offset":846},"indent":[1,1,1,1,1,1,1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"Our new hook accepts our contexts name for use in a thrown error message if its used outside of its provider. This is optional but will help with debugging the issue if you come across it. It then create a new context for us, passing in our generic or undefined. It then creates a new internal hook which runs the check for null or undefined for us by creating an additional context which is passed the parent functions context (the one we created first) and checking its value before returning it back. The parent function then returns a tuple with the inner hook and the parents contexts provider. Its set to const with a const assertion which sets the literals as readonly. ","position":{"start":{"line":19,"column":1,"offset":850},"end":{"line":19,"column":678,"offset":1527},"indent":[]}}],"position":{"start":{"line":19,"column":1,"offset":850},"end":{"line":19,"column":678,"offset":1527},"indent":[]}},{"type":"paragraph","children":[{"type":"text","value":"We can then use our new hook like so:","position":{"start":{"line":21,"column":1,"offset":1531},"end":{"line":21,"column":38,"offset":1568},"indent":[]}}],"position":{"start":{"line":21,"column":1,"offset":1531},"end":{"line":21,"column":38,"offset":1568},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"    interface ContextValues {\n        isValue: boolean;\n        setValue: React.Dispatch<React.SetStateAction<boolean>>;\n    }\n\n    const [useContextValue, ContextValueProvider] = useCreateNoNullContext<ContextValues>('useContextValue');","position":{"start":{"line":23,"column":1,"offset":1572},"end":{"line":30,"column":4,"offset":1834},"indent":[1,1,1,1,1,1,1]}},{"type":"paragraph","children":[{"type":"text","value":"We have created an interface which will be passed to the context hook as its type, we are also passing in the name of our context as a string to be used in an error message if thrown. The naming of the context and the provider can be anything but the order of destructuring is important as they are returned as the context first, then the provider. Making sure to wrap whatever components are going to use our context somewhere in the component tree we can then use our new context hook like so:","position":{"start":{"line":32,"column":1,"offset":1838},"end":{"line":32,"column":496,"offset":2333},"indent":[]}}],"position":{"start":{"line":32,"column":1,"offset":1838},"end":{"line":32,"column":496,"offset":2333},"indent":[]}},{"type":"code","lang":"typescript","meta":null,"value":"    const {isValue, setValue} = useContextValue();","position":{"start":{"line":34,"column":1,"offset":2337},"end":{"line":36,"column":4,"offset":2407},"indent":[1,1]}},{"type":"export","value":"export const _frontmatter = {\"title\":\"React context with TypeScript\",\"date\":\"2020-03-27T00:00:00.000Z\",\"published\":true,\"category\":\"TypeScript\",\"author\":\"Richard Haines\",\"keywords\":[\"react\",\"react context\",\"typescript\"],\"pin\":false}","position":{"start":{"line":38,"column":1,"offset":2409},"end":{"line":38,"column":233,"offset":2641},"indent":[]}}],"position":{"start":{"line":1,"column":1,"offset":0},"end":{"line":38,"column":233,"offset":2641}}},"scopeImports":["import React from 'react'"],"scopeIdentifiers":["React"],"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"React context with TypeScript\",\n  \"date\": \"2020-03-27T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"TypeScript\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"react\", \"react context\", \"typescript\"],\n  \"pin\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When we create a context using TypeScript the compiler expects us to provide a default value, usually, but not always, this is set to null or undefined. This is fine in a JavaScript project but when using TypeScript it means that we have to check for null or undefined every time we want to use the context. This is a helper hook that does the heavy lifting for us. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"function useCreateNoNullContext<T>(contextName: string) {\\n    const context = React.createContext<T | undefined>(undefined);\\n\\n    function useNoNullContext() {\\n        const noNullContext = React.useContext(context);\\n        if (!noNullContext) {\\n        throw new Error(`${contextName} must be used inside a provider with a value`);\\n        }\\n        return noNullContext;\\n    }\\n    return [useNoNullContext, context.Provider] as const;\\n    }\\n\")), mdx(\"p\", null, \"Our new hook accepts our contexts name for use in a thrown error message if its used outside of its provider. This is optional but will help with debugging the issue if you come across it. It then create a new context for us, passing in our generic or undefined. It then creates a new internal hook which runs the check for null or undefined for us by creating an additional context which is passed the parent functions context (the one we created first) and checking its value before returning it back. The parent function then returns a tuple with the inner hook and the parents contexts provider. Its set to const with a const assertion which sets the literals as readonly. \"), mdx(\"p\", null, \"We can then use our new hook like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"    interface ContextValues {\\n        isValue: boolean;\\n        setValue: React.Dispatch<React.SetStateAction<boolean>>;\\n    }\\n\\n    const [useContextValue, ContextValueProvider] = useCreateNoNullContext<ContextValues>('useContextValue');\\n\")), mdx(\"p\", null, \"We have created an interface which will be passed to the context hook as its type, we are also passing in the name of our context as a string to be used in an error message if thrown. The naming of the context and the provider can be anything but the order of destructuring is important as they are returned as the context first, then the provider. Making sure to wrap whatever components are going to use our context somewhere in the component tree we can then use our new context hook like so:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-typescript\"\n  }), \"    const {isValue, setValue} = useContextValue();\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","rawMDXOutput":"/* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nexport const _frontmatter = {\n  \"title\": \"React context with TypeScript\",\n  \"date\": \"2020-03-27T00:00:00.000Z\",\n  \"published\": true,\n  \"category\": \"TypeScript\",\n  \"author\": \"Richard Haines\",\n  \"keywords\": [\"react\", \"react context\", \"typescript\"],\n  \"pin\": false\n};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`When we create a context using TypeScript the compiler expects us to provide a default value, usually, but not always, this is set to null or undefined. This is fine in a JavaScript project but when using TypeScript it means that we have to check for null or undefined every time we want to use the context. This is a helper hook that does the heavy lifting for us. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function useCreateNoNullContext<T>(contextName: string) {\n    const context = React.createContext<T | undefined>(undefined);\n\n    function useNoNullContext() {\n        const noNullContext = React.useContext(context);\n        if (!noNullContext) {\n        throw new Error(\\`\\${contextName} must be used inside a provider with a value\\`);\n        }\n        return noNullContext;\n    }\n    return [useNoNullContext, context.Provider] as const;\n    }\n`}</code></pre>\n    <p>{`Our new hook accepts our contexts name for use in a thrown error message if its used outside of its provider. This is optional but will help with debugging the issue if you come across it. It then create a new context for us, passing in our generic or undefined. It then creates a new internal hook which runs the check for null or undefined for us by creating an additional context which is passed the parent functions context (the one we created first) and checking its value before returning it back. The parent function then returns a tuple with the inner hook and the parents contexts provider. Its set to const with a const assertion which sets the literals as readonly. `}</p>\n    <p>{`We can then use our new hook like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`    interface ContextValues {\n        isValue: boolean;\n        setValue: React.Dispatch<React.SetStateAction<boolean>>;\n    }\n\n    const [useContextValue, ContextValueProvider] = useCreateNoNullContext<ContextValues>('useContextValue');\n`}</code></pre>\n    <p>{`We have created an interface which will be passed to the context hook as its type, we are also passing in the name of our context as a string to be used in an error message if thrown. The naming of the context and the provider can be anything but the order of destructuring is important as they are returned as the context first, then the provider. Making sure to wrap whatever components are going to use our context somewhere in the component tree we can then use our new context hook like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`    const {isValue, setValue} = useContextValue();\n`}</code></pre>\n\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"}}